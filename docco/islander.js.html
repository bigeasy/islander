<!DOCTYPE html>

<html>
<head>
  <title>islander.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>islander.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>TODO Optionally surrender retries on collapse.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)
<span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString
<span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cadence'</span>)
<span class="hljs-keyword">var</span> unshift = [].unshift
<span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prolific.logger'</span>).createLogger(<span class="hljs-string">'islander'</span>)
<span class="hljs-keyword">var</span> Procession = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Islander</span> (<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">this</span>.id = id
    <span class="hljs-keyword">this</span>._cookie = <span class="hljs-string">'0'</span>
</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>TODO What is the structure, how are objects grouped? It appears that
<code>_seeking</code> are sent batches, generally zero or one outstanding messages
followed by zero or more flush messages. Confirm and document.</p>
<p>Our structure somelinke like the one in <code>Sequester</code>, but not really.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._seeking = { <span class="hljs-attr">messages</span>: [] }
</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Pending appears to be the next first entry into <code>_seeking</code>, one that we
biuld while we are waiting for all of the seeking entries to arrive.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._pending = []
</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Only pull one message from the outbox at a time.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.outbox = <span class="hljs-keyword">new</span> Procession
}

Islander.prototype._nextCookie = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._cookie = Monotonic.increment(<span class="hljs-keyword">this</span>._cookie, <span class="hljs-number">0</span>)
}

</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We publish a batch of messages and wait for that batch to pass through
consensus before publishing a subsequent batch. While we’re waiting for
messages to pass through pending messages accumulate in our pending list.</p>

            </div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Islander.prototype.publish = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{
    assert(body, <span class="hljs-string">'body cannot be null'</span>)
    <span class="hljs-keyword">this</span>._pending.push({ <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id, <span class="hljs-attr">cookie</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">body</span>: body, <span class="hljs-attr">promise</span>: <span class="hljs-literal">null</span> })
    <span class="hljs-keyword">this</span>._nudge()
}

</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Possibly publish a batch messages if there are messages available and we’re
not currently waiting on any to pass through consensus.</p>
<p>Properties of a submission are that our results will have promises that are
all from the same government. We reassign cookies. They are for Islander to
track, not for public consumption. If their are retries in the submission,
they will get new cookies.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Islander.prototype._nudge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (
        <span class="hljs-keyword">this</span>._seeking.messages.length == <span class="hljs-number">0</span> &amp;&amp;
        <span class="hljs-keyword">this</span>._pending.length != <span class="hljs-number">0</span>
    ) {
        <span class="hljs-keyword">var</span> messages = <span class="hljs-keyword">this</span>._pending.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._pending.length)
</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Assign cookies. Cookies get reset on retry. We need to reset their
promises to null because some of the messages may be retries.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        messages.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
            message.cookie = <span class="hljs-keyword">this</span>._nextCookie()
            message.promise = <span class="hljs-literal">null</span>
        }, <span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">this</span>._seeking = { <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>._cookie, <span class="hljs-attr">messages</span>: messages }
        <span class="hljs-keyword">this</span>.outbox.push({
            <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>._seeking.cookie,
            <span class="hljs-attr">messages</span>: <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>._seeking.messages))
        })
    }
}

</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>TODO Ensure that <code>_retry</code> is not called when we’re waiting on a send. Come
back and read through the code, add assertions.</p>

            </div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A flush message is a message with a cookie but no body. We send a flush
message to resolve race conditions between the waiting on a return value from
the submission of messages into the consensus and the arrival of messages
about changes in government with associated promise remapping.</p>

            </div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Islander.prototype._flush = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._seeking.cookie == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>._seeking.flushing = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">this</span>._seeking.cookie = <span class="hljs-keyword">this</span>._nextCookie()
        <span class="hljs-keyword">this</span>.outbox.push({
            <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>._seeking.cookie,
            <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id, <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>._seeking.cookie, <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span> }]
        })
    }
}

</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>TODO Need to timeout flushes, make sure we’re not hammering a broken
government.</p>

            </div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Called from the envelope with receipts from a submission to the consensus
algorithm. Using the <code>receipts</code> we assign a promise to each of messages we
sent based on their cookie. If <code>receipts</code> is <code>null</code>, than the submission
failed for whatever reason. We also mark the submission completed.</p>

            </div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Islander.prototype.sent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cookie, receipts</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._seeking.cookie == cookie) {
        <span class="hljs-keyword">if</span> (receipts == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">this</span>._seeking.cookie = <span class="hljs-literal">null</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._seeking.flushing) {
            <span class="hljs-keyword">this</span>._seeking.messages.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
                message.promise = receipts[message.cookie]
            })
        }
        <span class="hljs-keyword">this</span>._flush()
    }
}

</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Long diatribe. Initially about race conditions possibly introduced by the
process boundary between the Compassion Colleague and the Conference based
application that it is running. Doesn’t seem likely to me.</p>

            </div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Then a wondering why we don’t just track the cookies alone. This trails off
into a realization that the current system with the remapping is definitive.</p>

            </div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Possibly there is some confusion about using an outbox when there is only
ever one message outbound at a time. It is a single message with an array of
accumulated messages to send. A structure like Turnstile. Check seems more
appropriate, but it isn’t really, because the callback is assigned at
construction. Procession indicates you can connect later.</p>

            </div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Islander.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>User must provide items in order.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    assert(<span class="hljs-keyword">this</span>._previous == entry.previous || <span class="hljs-keyword">this</span>._previous == <span class="hljs-literal">null</span>, <span class="hljs-string">'out of order'</span>)

</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Make note of the previous promise.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._previous = entry.promise

</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>If we are not waiting on any messages then there is nothing to do.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._seeking.messages.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span>
    }

</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Take note of a new government.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (Monotonic.isBoundary(entry.promise, <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">var</span> map = entry.body.map
        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) {
</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>We will never remap anything so if any cookie we’re using for
flushing will now be invalid.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._seeking.cookie = <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>._seeking.messages[<span class="hljs-number">0</span>].promise == <span class="hljs-literal">null</span>) {
</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Failed a remap because of a consensus collapse or else we didn’t
get our receipts in time.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._flush()
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Monotonic.compare(<span class="hljs-keyword">this</span>._seeking.messages[<span class="hljs-number">0</span>].promise, entry.promise) &lt; <span class="hljs-number">0</span>) {
</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Remap.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._seeking.messages.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
                message.promise = map[message.promise]
            })
            assert(<span class="hljs-keyword">this</span>._seeking.messages.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">remapped, message</span>) </span>{
                <span class="hljs-keyword">return</span> remapped &amp;&amp; message.promise != <span class="hljs-literal">null</span>
            }, <span class="hljs-literal">true</span>), <span class="hljs-string">'remap did not remap all posted entries'</span>)
        }
</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>If this entry does pertains to us, look closer.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id == entry.body.id) {
</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Shift a message from our list of awaiting messages if we see it.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (entry.body.cookie == <span class="hljs-keyword">this</span>._seeking.messages[<span class="hljs-number">0</span>].cookie) {
            <span class="hljs-keyword">var</span> message = <span class="hljs-keyword">this</span>._seeking.messages.shift()
            assert(message.promise == <span class="hljs-literal">null</span> || message.promise == entry.promise, <span class="hljs-string">'promise mismatch'</span>)
</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>If we’ve consumed all the messages, maybe sent out another batch.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._seeking.messages.length == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">this</span>._nudge()
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.body.cookie == <span class="hljs-keyword">this</span>._seeking.cookie) {
</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>We’ve flushed so it is time to retry.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> retries = <span class="hljs-keyword">this</span>._seeking.messages.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._seeking.messages.length)
            <span class="hljs-built_in">Array</span>.prototype.unshift.apply(<span class="hljs-keyword">this</span>._pending, retries)
            <span class="hljs-keyword">this</span>._nudge()
        }
    }
}

Islander.prototype.enqueue = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, entry</span>) </span>{
    <span class="hljs-keyword">this</span>.push(entry)
})

Islander.prototype.health = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">waiting</span>: <span class="hljs-keyword">this</span>._seeking.messages.length,
        <span class="hljs-attr">pending</span>: <span class="hljs-keyword">this</span>._pending.length
    }
}

<span class="hljs-built_in">module</span>.exports = Islander

</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
